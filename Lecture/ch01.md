# SE Introduction

**本章重點**
> * 工業的演進
> * 軟體的重要性
> * 為什麼需要軟體工程
>     * 過去的失敗案例
>     * 軟體工程要解決的議題有哪些
> * 什麼是軟體？有哪些型態的軟體系統？
> * 寫程式和軟體工程的差異
>     * 包含哪些活動？
> * 軟體工程師的工程道德
> * 軟體工程的 FAQ

---

## Industrial revolution

![image](https://hackmd.io/_uploads/SkS3aln5ee.png)

* Industry 1.0: The Age of Mechanization
* Industry 2.0: The Age of Mass Production
* Industry 3.0: The Digital Revolution and the Dawn of Software
* Industry 4.0: The Era of Connectivity, AI, and Robotics

Here's a breakdown of the technological development from the Industrial Revolutions to the present, focusing on the rise of software, AI, and robotics, presented in English and as presentation slides.

---

#### **Industry 1.0: The Age of Mechanization (Late 18th Century - Mid-19th Century)**

* **Key Innovation:** Steam engine, water power.
* **Focus:** Transition from manual labor to machine-based manufacturing.
* **Impact:**
    * Factories emerged, shifting production from homes to centralized locations.
    * Major advancements in textiles, iron, and coal industries.
    * Improved transportation with steam-powered ships and railways.
* **Software's Role:** Non-existent. Technology was purely physical and mechanical.

---

#### **Industry 2.0: The Age of Mass Production (Late 19th Century - Early 20th Century)**

* **Key Innovations:** Electricity, assembly lines, internal combustion engine.
* **Focus:** Mass production, standardization of goods, new energy sources.
* **Impact:**
    * Enabled the large-scale production of goods like automobiles and appliances.
    * Led to significant advancements in communication (telegraph, telephone) and transportation (automobiles, airplanes).
    * Growth of large corporations and a more organized workforce.
* **Software's Role:** Still largely absent. Automation was mechanical and electro-mechanical.

---

#### **Industry 3.0: The Digital Revolution and the Dawn of Software (Mid-20th Century - Late 20th Century)**

* **Key Innovations:** Computers, semiconductors, the internet, programmable logic controllers (PLCs).
* **Focus:** Automation of production through electronics and information technology.
* **Impact:**
    * **The birth of software:** Early computers required complex programming, laying the foundation for software engineering.
    * **Rise of personal computers (PCs):** Democratized computing and led to the development of widespread applications like word processors and spreadsheets.
    * **Automation in manufacturing:** PLCs enabled precise control of machinery, increasing efficiency and reducing human intervention.
    * **Telecommunications advancements:** Paved the way for global connectivity.
* **Software's Role:** Emergence as a distinct discipline. Software started controlling machines and managing data.

---

#### **Industry 4.0: The Era of Connectivity, AI, and Robotics (Early 21st Century - Present)**

* **Key Innovations:** Internet of Things (IoT), Cloud Computing, Artificial Intelligence (AI), Machine Learning (ML), Big Data, Advanced Robotics.
* **Focus:** Smart factories, interconnected systems, data-driven decision-making, intelligent automation.
* **Impact:**
    * **Ubiquitous Software:** Software is now the backbone of almost every aspect of life and industry.
    * **AI and Machine Learning:**
        * Enable systems to learn from data, recognize patterns, and make predictions.
        * Driving innovation in fields like image recognition, natural language processing, and autonomous systems.
    * **Robotics:** Robots are becoming more sophisticated, collaborative (cobots), and capable of performing complex tasks alongside humans or autonomously.
    * **IoT:** Connects billions of devices, generating massive amounts of data that fuel AI and enable real-time monitoring and control.
    * **Cloud Computing:** Provides scalable, on-demand access to computing resources and software, facilitating rapid development and deployment.
* **Software's Role:** Central and pervasive. Software is not just controlling machines; it's making them intelligent, adaptive, and interconnected. It's the enabler of AI and the driver of automation.

---

## The Genesis of Software Engineering

* **Early Computing (1940s-1950s):** Initially, computers were primarily hardware-focused. Software was rudimentary and often custom-built for specific tasks. The advent of stored-program computers and early programming languages began to separate software from hardware, but development processes were informal.
 
* **The Software Crisis (1960s-1970s):** As software projects grew in scale and complexity, especially for large government and commercial applications, the inherent difficulties in managing their development became apparent. This led to widespread project failures and the realization that a more structured, engineering-like approach was necessary.

    ![image](https://hackmd.io/_uploads/ry43V-ncll.png)

    [Software crisis](/@nlhsueh/rkL_wWQhp)
 
* **Formalization and Conferences (Late 1960s - 1970s):** The term "software engineering" gained more formal traction through discussions and conferences. The **NATO Software Engineering Conferences in 1968 and 1969** were pivotal in promoting the idea of software development as a disciplined engineering practice. These conferences brought together experts to address the challenges of the software crisis and explore best practices.

    ![nato software engineering conference](https://static.isthisit.nz/images/2022-08-nato-software-engineering/conference-photo.png)

    👉 NATO software engineering conference

* **Establishment as a Discipline (1980s onwards):** By the 1980s, software engineering had solidified its place as a recognized discipline alongside computer science and traditional engineering fields. Concepts like **waterfall models, structured programming, and later, object-oriented programming**, emerged as attempts to bring order and predictability to software development.

* **Agile and Modern Practices:** The field has continued to evolve, with the rise of **agile methodologies** in the early 2000s emphasizing flexibility, collaboration, and iterative development, further shaping how software is engineered today.

* **AI-Powered Software Engineering**: Building on the foundation of agile and modern practices, the next generation of software engineering is poised to be transformed by AI. By leveraging AI to automate repetitive tasks, provide intelligent insights, and even assist in code generation, this new paradigm promises to accelerate development, enhance quality, and enable engineers to focus on more complex, creative problem-solving.

---

- Why we can't avoid software failure?
    - complexity of software
    - method we apply
- Problems that SE want to solve
    - improve quality
    - increase productivity
    - cost down the development effort
    - reduce the cycle time

---

## Software

![image](https://hackmd.io/_uploads/S1-EgWhqxe.png)

**IEEE definition:**

> ✅ Computer **programs**, **procedures**, and possibly associated **documentation** and **data** pertaining to the operation of a computer system. That is, software is consisted of *code*, *procedure*, *documentation*, *data* necessary for *operating* the software system.

除了程式碼以外，操作的程序、資料、文件是「軟體」的範圍。就像華航事件一般，多少是操作的問題所引起的，所以再考量軟體品質時，不能不把這些考量在內。

> 程式必須是為了給人看而寫，命令機器執行只是附帶任務。

---

### Good software system

軟體有其獨特性，其品質的定義也略有不同。我們看以下三種軟體品質的定義：

> 1️⃣ 一個系統，元件或流程滿足所指定的需求的程度。
>> The degree to which a system, component, or process meets specified requirements. (Crosby, 1979)

這樣的定義著重在「需求規格」。問題是，規格書通常都寫的不完整，以致於滿足規格書的系統，卻不能滿足使用者。

> 2️⃣ 一個系統，元件或流程滿足顧客或使用者的需求或期望的程度
>> The degree to which a system, components, or process meets customer or user needs or expects (Juran, 1998)

這樣的定義加強了使用者的需要與期望。但難道只要符合使用者的期待就是好的軟體嗎？Pressman  的定義加強了「專業軟體」的期望，例如在可維護性等特性，這些是使用者不會期待的特性，但卻是與品質有著強烈的關聯。

**Software Quality**: 
> 3️⃣ 符合明訂的功能與效能需求，明訂的開發標準，及非明定的專業軟體特性的程度。
>> Conformance to explicitly state functional and performance requirements, explicitly documented development standards, and implicit characteristics that are expected of all professionally developed software (Pressman)

這樣的定義似乎聽之有理，但仍然模糊。我們透過「品質模型」的描述，可以更了解何謂軟體品質。

> 👍 測試技巧可以短時間培養，建立品質文化需要長時間培養

Quality model: [ISO 9126 Model](/@nlhsueh/Hk0d1O73T)

![image](https://hackmd.io/_uploads/HykBW0U3T.png)

---

### Application types

In the software world, applications can be categorized into several types based on their functionality, platform, or domain. Here’s a breakdown of common types of software applications:

1. **Web Applications**
   - **E-commerce Platforms** (e.g., Amazon, eBay)
   - **Content Management Systems (CMS)** (e.g., WordPress, Joomla)
   - **Social Media Platforms** (e.g., Facebook, Instagram, Twitter)
   - **SaaS Applications** (e.g., Salesforce, Dropbox)
   - **Business Web Apps** (e.g., project management tools like Trello, Slack)

2. **Mobile Applications**
   - **Utility Apps** (e.g., Weather, Clock, Calculator)
   - **Social Networking Apps** (e.g., WhatsApp, Snapchat)
   - **Gaming Apps** (e.g., Clash of Clans, PUBG)
   - **Health and Fitness Apps** (e.g., Fitbit, MyFitnessPal)
   - **E-learning Apps** (e.g., Duolingo, Udemy)

3. **Desktop Applications**
   - **Productivity Software** (e.g., Microsoft Office, Adobe Creative Suite)
   - **Developer Tools** (e.g., Visual Studio, IntelliJ IDEA, Sublime Text)
   - **Design and Graphics Tools** (e.g., Photoshop, Sketch, Figma)
   - **Media Players** (e.g., VLC, Windows Media Player)
   - **Security Tools** (e.g., antivirus software like Norton, McAfee)

4. **Enterprise Applications**
   - **Enterprise Resource Planning (ERP) Systems** (e.g., SAP, Oracle ERP)
   - **Customer Relationship Management (CRM) Systems** (e.g., Salesforce, HubSpot)
   - **Human Resources Management Systems (HRMS)** (e.g., Workday, BambooHR)
   - **Supply Chain Management (SCM) Systems** (e.g., Odoo, Logility)

5. **Embedded Software**
   - **Firmware** (e.g., software in medical devices, automotive systems, or household appliances like smart TVs)
   - **IoT (Internet of Things) Devices** (e.g., smart thermostats, smartwatches)

6. **Game Development**
   - **Console Games** (e.g., PlayStation, Xbox games)
   - **PC Games** (e.g., Steam games)
   - **Mobile Games** (e.g., Candy Crush, Pokémon GO)

7. **Artificial Intelligence (AI) and Machine Learning (ML) Applications**
   - **Virtual Assistants** (e.g., Siri, Google Assistant, Alexa)
   - **Recommendation Engines** (e.g., Netflix, YouTube)
   - **Chatbots and Customer Support Systems** (e.g., Zendesk, Intercom)

8. **Data Analytics and Business Intelligence Applications**
   - **Data Visualization Tools** (e.g., Tableau, Power BI)
   - **Statistical Analysis Software** (e.g., R, SAS)
   - **Big Data Platforms** (e.g., Hadoop, Apache Spark)

9. **Cloud-based Applications**
   - **Cloud Storage** (e.g., Google Drive, OneDrive)
   - **Virtual Machines and Cloud Infrastructure** (e.g., AWS, Azure, Google Cloud)
   - **Cloud Databases** (e.g., MongoDB Atlas, Firebase)

10. **Scientific and Engineering Applications**
   - **Computer-Aided Design (CAD)** (e.g., AutoCAD, SolidWorks)
   - **Mathematical and Simulation Tools** (e.g., MATLAB, Simulink)
   - **Scientific Visualization** (e.g., PyMOL, ANSYS)

Each category serves specific use cases and industries, from everyday consumer tasks to complex enterprise or scientific needs.

---

### General issues that affect software

* **Heterogeneity**:  Increasingly, systems are required to operate as distributed systems across networks that include different types of computer and mobile devices. 
* **Business and social change**: Business and society are changing incredibly quickly as emerging economies develop and new technologies become available. They need to be able to change their existing software and to rapidly develop new software. 
* **Security and trust**: As software is intertwined with all aspects of our lives, it is essential that we can trust that software. 
* **Scale**: Software has to be developed across a very wide range of scales, from very small embedded systems in portable or wearable devices through to Internet-scale, cloud-based systems that serve a global community. 
Here are five common issues that can affect software development:
* **Technical Debt**: Accumulated shortcuts or poor design choices made during development can lead to complex, hard-to-maintain code that slows down future progress.
* **Poor Project Management**: Ineffective project planning, lack of timelines, unclear roles, or inefficient communication can lead to missed deadlines and poorly executed projects.
* **Lack of Testing and Quality Assurance**: Insufficient testing can lead to software bugs, security vulnerabilities, and poor user experiences, causing issues after release.
* **Team Collaboration and Communication Issues**: Miscommunication, lack of collaboration, or poorly distributed team roles can lead to misalignment between developers, designers, and stakeholders, affecting productivity and project outcomes.

---

![image](https://hackmd.io/_uploads/B1HFMCLnp.png)

👉 When the code grows into a large system, software engineering is needed

---

## Software Engineering

- [software engineering = coding?](https://docs.google.com/presentation/d/19va_iKSKUqG3irU58qg3NxQxZ5SqWM8dbC3pETC-xL4/edit#slide=id.p1)

---

### Engineering

![image](https://hackmd.io/_uploads/BkllZbh5eg.png)

> ✅ **Engineering** is the science, skill, and profession of acquiring and applying scientific, economic, social, and practical knowledge, in order to design and also build structures, machines, devices, systems, materials and processes.

---

### What is software engineering?

> - ✅ An engineering **discipline** that is concerned with all aspects of software production.
> - ✅ Adopt a **systematic** and **organized** approach to their work and use appropriate **tools** and **techniques** depending on the **problem** to be **solved**, the development **constraints** and the **resources** available.
> - ✅ A **systematic and organized** approach following a well-structured, methodical process for planning, designing, developing, testing, and maintaining software. It ensures that each phase of software development is executed efficiently and with attention to detail, reducing errors, improving collaboration, and increasing the chances of delivering high-quality software on time and within budget.

---

#### SE development approach
- Waterfall model
- Spiral model
- Agile method
    - incremental and iterative

---

#### SE activities

* **Software specification**, where customers and engineers define the software that is to be produced and the constraints on its operation.
* **Software development**, where the software is designed and programmed.
* **Software validation**, where the software is checked to ensure that it is what the customer requires.
* **Software evolution**, where the software is modified to reflect changing customer and market requirements.

    <img src="https://hackmd.io/_uploads/rJq1f0L2a.png" width="500">

    👉 Softwre engineering process and activities

---

#### SE components

##### Discipline

* Writing comments
* Specification before design
* Design before implementation
* Manage the requirement changes
* Design with interface, not implementation
* Make a estimation before development
* Manage the risk
* Record the design rationale

---

##### Myth

* If we get behind schedule, we can add more programmers and catch up
* Software is easy to change
* If we decide to outsource the software project to a third party, I can just relax and let that firm build it

---

##### Principle

* Open closed principle
* Anticipation of Change
* Design with abstraction
* Perform continuous validation
* Independent test team
* Principle of least surprise
* KISS

---

> 💡💬 就你的經驗，發展出一個軟體開發的原則與迷思，或是寫下你最認同的原則與迷思

---

##### Heuristics/Guidelines
* Nielsen’s Usability Heuristics
    * Visibility of System Status
    * Match Between System and the Real World
    * User Control and Freedom
    * Consistency and Standards
    * Error Prevention
    * Recognition Rather Than Recall
    * Flexibility and Efficiency of Use
    * Aesthetic and Minimalist Design
    * Help Users Recognize, Diagnose, and Recover from Errors
    * Help and Documentation

    [Intro to UX](https://docs.google.com/presentation/d/1WHFbBNLGgeCFRYinNHydKIoZUA-in64f11McvFJDHT8/edit?usp=sharing)

---

##### Tools and techniques

* **Version Control Tools**: Help manage code changes, track history, collaborate with teams, and handle multiple versions of a project. For example: Git and Subversion. 

* **Integrated Development Environments (IDEs)**: Provide a comprehensive environment for writing, testing, and debugging code, often with built-in support for project management and version control. For example, Intellij and VS code. 

* **Agile Development Techniques**: Promote iterative, flexible, and collaborative approaches to software development. For example, Scrum, Kanban

* **Automated Testing Tools**: Automate the testing process to ensure code correctness, improve quality, and catch bugs early. For example, Junit, Jest and Selenium. 
 
* **Continuous Integration/Continuous Deployment (CI/CD) Tools**: Automate the integration, testing, and deployment process to reduce manual effort and ensure a streamlined workflow from code commits to production releases. For example: Jenkins, CircleCI. 

* **Project Management Tools**: Track project progress, manage tasks, allocate resources, and monitor timelines. For example, Jira and Trello. 

* **Architecture and Design Tools**: Help in designing system architectures, creating UML diagrams, and ensuring software follows design patterns. For example, Enterprise Architect UML modeling tool, and Lucidchart. 

* **Collaboration Tools**: Facilitate communication, document sharing, and collaboration among team members. For example Slack, Confluence. 

* **Design pattern techniques**: Provide a reusable solution to common problems in software design. These patterns provide a standard way to solve recurring issues within a given context, making code more flexible, maintainable, and scalable. Design patterns help developers write better-organized code, promoting best practices and reducing redundancy. 

    <img src="https://i.imgur.com/KIeMPxd.png" width="500">
    
    👉 Decorator design pattern

* **Performance Monitoring and Profiling Tools**: Monitor the performance of software in production and optimize code to ensure efficiency and scalability. For example: New Relic and JProfiler. 

* **Database Management and Query Tools**: Manage and interact with databases, optimize queries, and ensure data integrity. For example: MySQL Workbench and Postman. 

* **AI-Powered Coding Assistants**: These tools use large language models (LLMs) to provide real-time code suggestions, generate boilerplate code, and even complete entire functions based on natural language prompts. They act as a **pair programmer**, significantly speeding up development and reducing cognitive load. Examples are: GitHub Copilot, Amazon CodeWhisperer.

* **Automated Documentation and Code Generation**: AI tools are now capable of analyzing codebases and automatically generating documentation, README files, and API specifications. They also assist with creating and updating user stories and technical design documents, ensuring that documentation stays consistent with the codebase. 

* **AI for Code Analysis and Security**: These tools leverage AI to go beyond traditional static analysis. They can not only detect bugs and vulnerabilities but also suggest complex fixes, refactor code for improved performance and readability, and even automatically generate unit tests. They can analyze code behavior and identify subtle security issues that manual reviews or simpler tools might miss. Examples are Snyk, DeepCode AI.

> 💡💬 寫下你覺得最好用的軟體開發工具（別人可能忽略的）

---

##### Constraints and Resources

**Constraints** are the limitations or restrictions that shape the scope and nature of software development. These constraints often guide the decision-making process and influence the tools, methodologies, and techniques chosen for a project.

- **Time Constraints**: The deadline or time frame within which the software must be delivered.  
- **Budget Constraints**: The financial limitations available for the development of software.
- **Technology Constraints**: Certain technological requirements or limitations (e.g., the need to develop within a specific tech stack).
- **Regulatory or Compliance Constraints**: Legal or industry-specific requirements that must be met (e.g., security standards like **GDPR** or **HIPAA**).
- **Scalability Constraints**: The need for the software to handle a growing number of users, transactions, or data over time.

**Resources** refer to the personnel, technology, infrastructure, and other assets available for the project. Understanding the resources you have helps to determine what tools, techniques, and approaches are feasible for delivering the software.

- **Human Resources**: The developers, designers, testers, and managers who are part of the team.
- **Technological Resources**: Available hardware, software, infrastructure, and development tools.
- **Knowledge and Expertise**: The level of technical expertise and experience available in the team.
- **Infrastructure Resources**: The hardware or cloud infrastructure where the software will be hosted.
- **Time and Budget Resources**: The project’s timeline and financial resources, which can affect the scope and ambition of the project.

---

#### Apply SE to solve problems

> **Balancing Constraints and Resources**:
The key to success in software engineering is balancing constraints with available resources. To do this:

1. **Prioritize Requirements**: Understand what is critical to deliver, and what can be postponed or reduced in scope. For example, focus on essential features first and plan for future iterations to handle additional features.

2. **Select Appropriate Tools and Techniques**: Based on constraints and resources, choose the tools and methodologies that best fit the situation.

3. **Optimize Development Process**: Adopt development techniques that allow flexibility, reduce bottlenecks, and ensure high-quality output.

4. **Leverage Automation and Continuous Integration**: Maximize productivity by automating repetitive tasks like testing, code integration, and deployment.

---

##### Example Scenario:

* **Problem**: A startup needs to launch a mobile app within 6 months on a tight budget. The app must also handle a growing user base and comply with basic security regulations.

* **Constraints**:
    - **Time**: 6-month deadline.
    - **Budget**: Limited, so expensive tools and infrastructure are not an option.
    - **Scalability**: The app should be prepared to handle growth as the user base increases.
    - **Security**: Must adhere to basic security guidelines, such as encrypting sensitive user data.

* **Resources**:
    - **Human Resources**: A small team of 4 developers with expertise in JavaScript and mobile app development.
    - **Technology**: Basic cloud infrastructure for hosting and a preference for cross-platform development to save time.
    - **Budget**: Enough to cover basic cloud services but no extra for costly licenses.

* **Solution**:
    - **Tool Selection**: Use **React Native** for cross-platform development (Android and iOS), allowing the team to write code once and deploy it to both platforms.
    - **Security**: Implement basic security measures such as **SSL encryption** and **OAuth 2.0** for user authentication.
    - **Hosting**: Use low-cost cloud services like **AWS Free Tier** initially, with plans to scale as user demand grows.
    - **Agile Development**: Adopt **Scrum** with 2-week sprints to deliver a minimum viable product (MVP) within the first few months, iterating and adding features as the project progresses.
    - **Automation**: Set up **GitHub Actions** for automated testing and deployment to ensure rapid development and quick fixes to production.

---

## Code of Ethics

![image](https://hackmd.io/_uploads/SJrmz-2clx.png)


ACM/IEEE 軟體工程師職業道德守則（Software Engineering Code of Ethics and Professional Practice）是由美國電腦學會（Association for Computing Machinery，簡稱 ACM）和 IEEE（Institute of Electrical and Electronics Engineers）共同制定的一套道德守則，旨在引導軟體工程師在其專業實踐中遵守高標準的道德行為和職業操守。以下是其主要內容：

1. **公眾利益（Public）**：軟體工程師應該考慮到公眾的利益，包括但不限於健康、安全和福祉。他們應該專注於開發安全可靠的軟體產品，並確保這些產品對社會產生積極的影響。
2. **客戶和雇主（Client and Employer）**：軟體工程師應該尊重客戶和雇主的需求，並致力於提供高品質的產品和服務。他們應該遵循專業標準，確保所提供的產品符合客戶的期望，並保護雇主的利益。
3. **產品（Product）**：軟體工程師應該確保所開發的產品具有高質量、高效率和高可靠性。他們應該專注於產品的功能、性能、安全性和可維護性，並確保產品符合相關的法律和法規要求。
4. **判斷（Judgment）**：軟體工程師應該行使良好的判斷力，並在面對倫理和專業問題時做出正確的決策。他們應該尊重他人的意見和觀點，並考慮到各種可能的後果。
5. **管理（Management）**：軟體工程師應該遵循專業的管理原則，並確保團隊成員之間的溝通和合作。他們應該建立良好的工作環境，並確保團隊成員的專業發展和職業滿足。
6. **專業發展（Professional Development）**：軟體工程師應該持續學習和提升自己的專業能力，並遵守相關的專業準則和標準。他們應該參加相關的培訓和教育活動，並不斷改進自己的技能和知識。

> 總的來說，ACM/IEEE **軟體工程師職業道德守則** 旨在促進軟體工程師的專業行為和職業操守，並確保他們在其專業實踐中遵守高標準的道德準則。這些準則提供了一個指導框架，幫助軟體工程師在面對各種倫理和專業問題時做出正確的決策。

---

💡💬 舉例一些違反及符合 Code of ethics 的例子。
* 燈泡的「龐氏陰謀(Phoebus cartel)」(「計劃性報廢」)
* 軟體的停止支援與更新、不相容與強制訂閱、與昂貴的維護合約
* Volkswagen 的「柴油門」事件 (Dieselgate)
* 暗黑 UI 模式 (Dark UX Patterns)
* Facebook 的劍橋分析醜聞 (Cambridge Analytica scandal)

> 💡💬 舉例說明一些暗黑 UI 模式，最好是你親身經歷的

---

<a href="https://g.co/gemini/share/2da5d25a4cca"><img src = "https://hackmd.io/_uploads/B1ZJscSsxg.png" width=200></a>

👉 資料即黃金

---

<a href="https://g.co/gemini/share/022dd19085b9"><img src = "https://hackmd.io/_uploads/HJJuIb1olg.png" width=200></a>

👉 開發商、營運商、與使用者的糾葛

---

## FQA of software engineering

**What is software?**
* Computer programs and associated documentation. Software products may be developed for a particular customer or may be developed for a general market.

**What are the attributes of good software?**
* Good software should deliver the required functionality and performance to the user and should be maintainable, dependable and usable.

**What is software engineering?**
* Software engineering is an engineering discipline that is concerned with all aspects of software production.

**What are the fundamental software engineering activities?**
* Software specification, software development, software validation and software evolution.

**What is the difference between software engineering and computer science?**
* Computer science focuses on theory and fundamentals; software engineering is concerned with the practicalities of developing and delivering useful software.

**What is the difference between software engineering and system engineering?**
* System engineering is concerned with all aspects of computer-based systems development including hardware, software and process engineering. Software engineering is part of this more general process.

**What are the costs of software engineering?**
* Roughly 60% of software costs are development costs, 40% are testing costs. For custom software, evolution costs often exceed development costs.

**What are the best software engineering techniques and methods?**
* While all software projects have to be professionally managed and developed, different techniques are appropriate for different types of system. For example, games should always be developed using a series of prototypes whereas safety critical control systems require a complete and analyzable specification to be developed. You can’t, therefore, say that one method is better than another.

---

## Reference

Sommerville SE book
- [Web site](https://software-engineering-book.com/)
- [All slides](https://drive.google.com/drive/u/0/folders/1aU-KsrwQsNMk3Gzlj15wihctOioIMBjN)
- [Slide- this chapter](https://docs.google.com/presentation/d/1CLQaKE9g9EQE0XWGd2yiA9TnyB8-H-qf/edit?usp=sharing&ouid=109022309423128079509&rtpof=true&sd=true)
